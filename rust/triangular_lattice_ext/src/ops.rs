use blochfunc::{BlochFunc, BlochFuncSet};
use common::*;
use fnv::FnvHashMap;
/// Operators generated by functions in this module assume translational
/// symmetry and will work with systems regardless of whether total Sz is a good
/// quantum number.
use num_complex::Complex;

pub fn ss_z_elements(sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>),
                     orig_state: &BlochFunc)
                     -> f64 {
    let (ref site1, ref site2) = *sites;
    let mut same_dir = 0_i32;
    for (&s1, &s2) in site1.iter().zip(site2.iter()) {
        let (upup, downdown) = repeated_spins(orig_state.lead, s1, s2);
        if upup {
            same_dir += 1
        };
        if downdown {
            same_dir += 1
        };
    }
    let diff_dir = site1.len() as i32 - same_dir;
    0.25 * (same_dir - diff_dir) as f64
}

/// Generate the xy-elements of an XXZ chain. Note: the matrix generated here
/// corresponds to Σ(sx_i * sx_j + sy_i + sy_j), so if you are thinking in terms
/// of s+ and s-, the 1/2 is already included in the output
#[allow(non_snake_case)]
#[allow(unused)]
pub fn ss_xy_elements(nx: Dim, ny: Dim,
                      sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>),
                      orig_state: &BlochFunc,
                      dec_to_ind: &FnvHashMap<BinaryBasis, u32>,
                      hashtable: &FnvHashMap<&BinaryBasis, &BlochFunc>)
                      -> FnvHashMap<u32, Complex<f64>> {
    let J = Complex::new(0.5, 0.);
    let mut j_element = FnvHashMap::default();
    let (ref site1, ref site2) = *sites;
    for (&s1, &s2) in site1.iter().zip(site2.iter()) {
        let (updown, downup) = exchange_spin_flips(orig_state.lead, s1, s2);
        let mut new_dec: BinaryBasis;
        match (updown, downup) {
            (true, false) => new_dec = orig_state.lead - s1 + s2,
            (false, true) => new_dec = orig_state.lead + s1 - s2,
            _ => continue
        }
        match find_leading_state(new_dec, &hashtable) {
            None => (),
            Some((cntd_state, phase)) => {
                let j = *(dec_to_ind.get(&(cntd_state.lead)).unwrap());
                let coeff = phase * coeff(&orig_state, &cntd_state);

                let element = match j_element.get(&j) {
                    Some(&c) => c + J * coeff,
                    None => J * coeff
                };
                j_element.insert(j, element);
            }
        }
    }
    j_element
}

#[allow(non_snake_case)]
pub fn ss_ppmm_elements(nx: Dim, ny: Dim,
                        sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>),
                        orig_state: &BlochFunc,
                        dec_to_ind: &FnvHashMap<BinaryBasis, u32>,
                        hashtable: &FnvHashMap<&BinaryBasis, &BlochFunc>)
                        -> FnvHashMap<u32, Complex<f64>> {
    let J = Complex::new(1., 0.);
    let mut j_element = FnvHashMap::default();
    let (ref site1, ref site2) = *sites;
    for (&s1, &s2) in site1.iter().zip(site2.iter()) {
        let (upup, downdown) = repeated_spins(orig_state.lead, s1, s2);
        let mut new_dec: BinaryBasis;
        let mut _gamma = Complex::new(0., 0.);
        match (upup, downdown) {
            (true, false) => {
                new_dec = orig_state.lead - s1 - s2;
                _gamma += gamma(nx, ny, s1, s2).conj();
            }
            (false, true) => {
                new_dec = orig_state.lead + s1 + s2;
                _gamma += gamma(nx, ny, s1, s2);
            }
            _ => continue
        }
        match find_leading_state(new_dec, &hashtable) {
            None => (),
            Some((cntd_state, phase)) => {
                let j = *(dec_to_ind.get(&(cntd_state.lead)).unwrap());
                let coeff = phase * coeff(&orig_state, &cntd_state);

                let element = match j_element.get(&j) {
                    Some(&c) => c + J * coeff * _gamma,
                    None => J * coeff * _gamma
                };
                j_element.insert(j, element);
            }
        }
    }
    j_element
}

#[allow(non_snake_case)]
pub fn ss_pmz_elements(nx: Dim, ny: Dim,
                       sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>),
                       orig_state: &BlochFunc,
                       dec_to_ind: &FnvHashMap<BinaryBasis, u32>,
                       hashtable: &FnvHashMap<&BinaryBasis, &BlochFunc>)
                       -> FnvHashMap<u32, Complex<f64>> {
    let J = Complex::new(0., 1.); // the entire operator was multiplied by i
    let mut j_element = FnvHashMap::default();
    let (ref site1, ref site2) = *sites;
    for (&s_1, &s_2) in site1.iter().zip(site2.iter()) {
        for &(s1, s2) in [(s_1, s_2), (s_2, s_1)].iter() {
            let z_contrib = if orig_state.lead | s1 == orig_state.lead {
                0.5
            } else {
                -0.5
            };

            let mut new_dec: BinaryBasis;
            let mut _gamma = Complex::new(0., 0.);
            if orig_state.lead | s2 == orig_state.lead {
                new_dec = orig_state.lead - s2;
                _gamma += gamma(nx, ny, s1, s2).conj();
            } else {
                new_dec = orig_state.lead + s2;
                _gamma -= gamma(nx, ny, s1, s2);
            }

            match find_leading_state(new_dec, &hashtable) {
                None => (),
                Some((cntd_state, phase)) => {
                    let j = *(dec_to_ind.get(&(cntd_state.lead)).unwrap());
                    let coeff = phase * coeff(&orig_state, &cntd_state);

                    let element = match j_element.get(&j) {
                        Some(&c) => c + J * z_contrib * coeff * _gamma,
                        None => J * z_contrib * coeff * _gamma
                    };
                    j_element.insert(j, element);
                }
            }
        }
    }
    j_element
}

/// Generate the elements of the chiral term (\vec{S_1} \times \vec{S_2}) \cdot
/// \vec{S_3} which could be written as 1/2 i Σ_{ijk} S^z_i (S^+_j S^-_k - S^-_j
/// S^+_k). The factor of 1/2 is already included in the output
#[allow(unused)]
#[allow(non_snake_case)]
pub fn sss_chi_elements(nx: Dim, ny: Dim,
                        sites: &(Vec<BinaryBasis>,
                         Vec<BinaryBasis>,
                         Vec<BinaryBasis>),
                        orig_state: &BlochFunc,
                        dec_to_ind: &FnvHashMap<BinaryBasis, u32>,
                        hashtable: &FnvHashMap<&BinaryBasis, &BlochFunc>)
                        -> FnvHashMap<u32, Complex<f64>> {
    let J = Complex::new(0., 0.5);
    let mut j_element = FnvHashMap::default();
    let (ref site1, ref site2, ref site3) = *sites;

    let zip3 = site1.iter()
                    .zip(site2.iter())
                    .zip(site3.iter())
                    .map(|((x, y), z)| (x, y, z));

    for (&s1, &s2, &s3) in zip3 {
        for _ in 0..3 {
            let (mut si, mut sj, mut sk) = (s1, s2, s3);
            let mut s_tmp: BinaryBasis;
            for _ in 0..3 {
                // switch ijk orders
                s_tmp = si;
                si = sj;
                sj = sk;
                sk = s_tmp;

                let (updown, downup) = exchange_spin_flips(orig_state.lead, sj, sk);
                let mut new_dec: BinaryBasis;
                match (updown, downup) {
                    (true, false) => new_dec = orig_state.lead - sj + sk,
                    (false, true) => new_dec = orig_state.lead + sj - sk,
                    _ => continue
                }
                match find_leading_state(new_dec, &hashtable) {
                    None => (),
                    Some((cntd_state, phase)) => {
                        let j = *(dec_to_ind.get(&(cntd_state.lead)).unwrap());
                        let coeff = phase * coeff(&orig_state, &cntd_state);

                        let z_contrib = if orig_state.lead | si == orig_state.lead {
                            0.5
                        } else {
                            -0.5
                        };

                        let element = match j_element.get(&j) {
                            Some(&c) => c + J * z_contrib * coeff,
                            None => J * z_contrib * coeff
                        };
                        j_element.insert(j, element);
                    }
                }
            }
        }
    }
    j_element
}

pub fn ss_z(sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>), bfuncs: &BlochFuncSet)
            -> CoordMatrix<CComplex<f64>> {
    let dims = bfuncs.nonzero;
    let (ind_to_dec, _) = gen_ind_dec_conv_dicts(&bfuncs);

    let mut data: Vec<CComplex<f64>> = Vec::with_capacity(dims as usize);
    let cols = (0..dims as u32).collect::<Vec<u32>>();
    let rows = (0..dims as u32).collect::<Vec<u32>>();
    for i in 0..dims as u32 {
        let orig_state = ind_to_dec.get(&i).unwrap();
        let i_element = ss_z_elements(&sites, &orig_state);
        let re = i_element;
        let im = 0.;
        data.push(CComplex { re, im });
    }
    CoordMatrix::new(data, cols, rows, dims, dims)
}

fn off_diag_ops<T>(element_f: fn(nx: Dim,
                    ny: Dim,
                    sites: &T,
                    orig_state: &BlochFunc,
                    dec_to_ind: &FnvHashMap<BinaryBasis, u32>,
                    hashtable: &FnvHashMap<&BinaryBasis,
                                &BlochFunc>)
                    -> FnvHashMap<u32, Complex<f64>>,
                   sites: &T, bfuncs: &BlochFuncSet)
                   -> CoordMatrix<CComplex<f64>> {
    let dims = bfuncs.nonzero;
    let hashtable = BlochFuncSet::build_dict(&bfuncs);
    let (ind_to_dec, dec_to_ind) = gen_ind_dec_conv_dicts(&bfuncs);

    let alloc_size = dims * (1 + 8 * (bfuncs.nx * bfuncs.ny).raw_int());
    let mut data: Vec<CComplex<f64>> = Vec::with_capacity(alloc_size as usize);
    let mut cols: Vec<u32> = Vec::with_capacity(alloc_size as usize);
    let mut rows: Vec<u32> = Vec::with_capacity(alloc_size as usize);
    for i in 0..dims as u32 {
        let orig_state = ind_to_dec.get(&i).unwrap();
        let ij_elements = element_f(bfuncs.nx,
                                    bfuncs.ny,
                                    sites,
                                    &orig_state,
                                    &dec_to_ind,
                                    &hashtable);
        for (j, entry) in ij_elements.into_iter() {
            rows.push(i);
            cols.push(j);
            data.push(CComplex::from_num_complex(entry));
        }
    }
    CoordMatrix::new(data, cols, rows, dims, dims)
}

pub fn ss_xy(sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>), bfuncs: &BlochFuncSet)
             -> CoordMatrix<CComplex<f64>> {
    off_diag_ops(ss_xy_elements, &sites, &bfuncs)
}

pub fn ss_ppmm(sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>),
               bfuncs: &BlochFuncSet)
               -> CoordMatrix<CComplex<f64>> {
    off_diag_ops(ss_ppmm_elements, &sites, &bfuncs)
}

pub fn ss_pmz(sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>), bfuncs: &BlochFuncSet)
              -> CoordMatrix<CComplex<f64>> {
    off_diag_ops(ss_pmz_elements, &sites, &bfuncs)
}

pub fn sss_chi(sites: &(Vec<BinaryBasis>, Vec<BinaryBasis>, Vec<BinaryBasis>),
               bfuncs: &BlochFuncSet)
               -> CoordMatrix<CComplex<f64>> {
    off_diag_ops(sss_chi_elements, &sites, &bfuncs)
}
